package main

import (
	"errors"
	"flag"
	"fmt"
	"github.com/dave/jennifer/jen"
	"go/ast"
	"go/parser"
	"go/token"
	"path"
	"strconv"
	"strings"
)

type SerializableField struct {
	Name  string
	Type  string
	Slice bool
}

type Packet struct {
	Name      string
	Id, State int
	Fields    []SerializableField
}

func main() {

	flag.Parse()
	if flag.NArg() == 0 {
		fmt.Println("Usage: go run generation/gen.go <filename>")
		return
	}

	filename := flag.Arg(0)
	packets, err := parse(filename)
	if err != nil {
		panic(err)
	}

	file := generate(packets)

	basename, dir := path.Base(filename), path.Dir(filename)
	newFilename := path.Join(dir, "zz_"+basename)

	if err = file.Save(newFilename); err != nil {
		panic(err)
	}
}

func parse(filename string) ([]Packet, error) {

	f, err := parser.ParseFile(token.NewFileSet(), filename, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var packets []Packet

	for _, decl := range f.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			continue
		}
		if decl.Doc == nil {
			continue
		}
		comment := strings.TrimSpace(decl.Doc.List[0].Text[2:])
		if !strings.HasPrefix(comment, "packet:") {
			continue
		}
		state, id, err := parsePacketID(comment)
		if err != nil {
			return nil, err
		}
		spec, ok := decl.Specs[0].(*ast.TypeSpec)
		if !ok {
			continue
		}
		t := spec.Type
		structName := spec.Name.Name
		st, ok := t.(*ast.StructType)
		if !ok {
			continue
		}
		var fields []SerializableField
		for _, field := range st.Fields.List {
			for _, name := range field.Names {
				if sel, ok := field.Type.(*ast.SelectorExpr); ok {
					fields = append(fields, SerializableField{
						Name: name.Name,
						Type: sel.Sel.Name,
					})
				} else if arr, ok := field.Type.(*ast.ArrayType); ok {
					if sel, ok := arr.Elt.(*ast.SelectorExpr); ok {
						fields = append(fields, SerializableField{
							Name:  name.Name,
							Type:  sel.Sel.Name,
							Slice: true,
						})
					}
				}
			}
		}
		packets = append(packets, Packet{
			Id:     id,
			State:  state,
			Name:   structName,
			Fields: fields,
		})
	}

	return packets, nil
}

func parsePacketID(comment string) (int, int, error) {
	parts := strings.Split(strings.TrimSpace(comment), ":")
	if len(parts) != 3 {
		return 0, 0, errors.New("invalid packet id: " + comment)
	}
	state, err := strconv.ParseInt(parts[1], 16, 32)
	if err != nil {
		return 0, 0, err
	}
	id, err := strconv.ParseInt(parts[2], 16, 32)
	if err != nil {
		return 0, 0, err
	}
	return int(state), int(id), nil
}

func generate(packets []Packet) *jen.File {
	f := jen.NewFile("packet")
	f.HeaderComment("Code generated by generation/gen.go. DO NOT EDIT.")
	f.ImportName("gomc/src/protocol/types", "types")
	f.ImportName("gomc/src/protocol", "protocol")

	var constructors []jen.Code
	for _, p := range packets {
		if !strings.HasPrefix(p.Name, "Serverbound") {
			continue
		}
		constructors = append(constructors, jen.Id(fmt.Sprintf("serverbound[%d][%d]", p.State, p.Id)).
			Op("=").Func().Parens(nil).Id("SerializablePacket").Block(
			jen.Return(jen.Id("&"+p.Name).Block(nil)),
		))
	}
	if len(constructors) > 0 {
		f.Func().Id("init").Parens(nil).Block(constructors...).Line()
	}

	for _, p := range packets {
		var code []jen.Code
		code = append(code, jen.Var().Id("buf").Qual("bytes", "Buffer"))
		for _, field := range p.Fields {
			if field.Slice {
				code = append(code, jen.Id("buf").Dot("Write").Parens(jen.Qual("gomc/src/protocol/types",
					"VarInt").Parens(jen.Len(jen.Id("p").Dot(field.Name))).Dot("Marshal").Parens(nil)))
				code = append(code, jen.For(jen.List(jen.Id("_"), jen.Id("v")).Op(":=").Range().Id("p").
					Dot(field.Name)).Block(jen.Id("buf").Dot("Write").Parens(jen.Id("v").Dot("Marshal").Parens(nil))))
			} else {
				code = append(code, jen.Id("buf").Dot("Write").
					Parens(jen.Id(fmt.Sprintf("p.%s.Marshal()", field.Name))))
			}
		}
		code = append(code, jen.Return(jen.Id("buf").Dot("Bytes").Parens(nil)))
		f.Func().Parens(jen.Id("p").Id("*" + p.Name)).Id("Serialize").
			Parens(nil).Id("[]byte").Block(code...).Line()
	}

	for _, p := range packets {
		var code []jen.Code
		b := "_"
		if len(p.Fields) > 0 {
			b = "b"
			code = append(code, jen.Var().Id("err").Id("error"))
			code = append(code, jen.Id("r").Op(":=").Qual("bytes", "NewReader").Parens(jen.Id("b")))
		}
		for _, field := range p.Fields {
			if field.Slice {
				code = append(code, jen.Var().Id("n"+field.Name).Qual("gomc/src/protocol/types", "VarInt").Line().
					List(jen.Id("n"+field.Name), jen.Id("_"), jen.Id("err")).Op("=").
					Qual("gomc/src/protocol/types", "ReadVarInt").Parens(jen.Id("r")).Line().
					If(jen.Id("err").Op("!=").Nil()).Block(jen.Return(jen.Id("err"))))
				code = append(code, jen.Id("p").Dot(field.Name).Op("=").Make(jen.Index(nil).
					Qual("gomc/src/protocol/types", field.Type), jen.Id("n"+field.Name)).Line().
					For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").
						Len(jen.Id("p").Dot(field.Name)), jen.Id("i").Op("++")).Block(
					jen.List(jen.Id("p").Dot(field.Name).Index(jen.Id("i")), jen.Id("_"), jen.Id("err")).
						Op("=").Qual("gomc/src/protocol/types", "Read"+field.Type).Parens(jen.Id("r")),
					jen.If(jen.Id("err").Op("!=").Nil()).Block(jen.Return(jen.Id("err"))),
				))
			} else {
				code = append(code, jen.List(jen.Id("p").Dot(field.Name), jen.Id("_"), jen.Id("err")).
					Op("=").Qual("gomc/src/protocol/types", "Read"+field.Type).Parens(jen.Id("r")))
				code = append(code, jen.If(jen.Id("err").Op("!=").Nil().Block(
					jen.Return(jen.Id("err")),
				)))
			}
		}
		code = append(code, jen.Return(jen.Nil()))
		f.Func().Parens(jen.Id("p").Id("*" + p.Name)).Id("Deserialize").
			Parens(jen.Id(b).Id("[]byte")).Id("error").Block(code...).Line()
	}

	for _, p := range packets {
		f.Func().Parens(jen.Id("*" + p.Name)).Id("ID").Parens(nil).
			Id("int").Block(jen.Return().Lit(p.Id)).Line()
	}

	for _, p := range packets {
		f.Func().Parens(jen.Id("*"+p.Name)).Id("State").Parens(nil).
			Qual("gomc/src/protocol", "State").Block(jen.Return().Id(strconv.Itoa(p.State))).Line()
	}

	return f
}
