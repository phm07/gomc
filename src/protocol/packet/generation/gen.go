package main

import (
	"errors"
	"flag"
	"fmt"
	"github.com/dave/jennifer/jen"
	"go/ast"
	"go/parser"
	"go/token"
	"path"
	"strconv"
	"strings"
)

type SerializableField struct {
	Name string
	Type string
}

type Packet struct {
	Name      string
	Id, State int
	Fields    []SerializableField
}

func main() {

	flag.Parse()
	if flag.NArg() == 0 {
		fmt.Println("Usage: go run generation/gen.go <filename>")
		return
	}

	filename := flag.Arg(0)
	packets, err := parse(filename)
	if err != nil {
		panic(err)
	}

	file := generate(packets)

	basename, dir := path.Base(filename), path.Dir(filename)
	newFilename := path.Join(dir, "zz_"+basename)

	if err = file.Save(newFilename); err != nil {
		panic(err)
	}
}

func parse(filename string) ([]Packet, error) {

	f, err := parser.ParseFile(token.NewFileSet(), filename, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var packets []Packet

	for _, decl := range f.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok || decl.Tok != token.TYPE {
			continue
		}
		if decl.Doc == nil {
			continue
		}
		comment := strings.TrimSpace(decl.Doc.List[0].Text[2:])
		if !strings.HasPrefix(comment, "packet:") {
			continue
		}
		state, id, err := parsePacketID(comment)
		if err != nil {
			return nil, err
		}
		spec, ok := decl.Specs[0].(*ast.TypeSpec)
		if !ok {
			continue
		}
		t := spec.Type
		structName := spec.Name.Name
		st, ok := t.(*ast.StructType)
		if !ok {
			continue
		}
		var fields []SerializableField
		for _, field := range st.Fields.List {
			if sel, ok := field.Type.(*ast.SelectorExpr); ok {
				fields = append(fields, SerializableField{
					Name: field.Names[0].Name,
					Type: sel.Sel.Name,
				})
			}
		}
		packets = append(packets, Packet{
			Id:     id,
			State:  state,
			Name:   structName,
			Fields: fields,
		})
	}

	return packets, nil
}

func parsePacketID(comment string) (int, int, error) {
	parts := strings.Split(strings.TrimSpace(comment), ":")
	if len(parts) != 3 {
		return 0, 0, errors.New("invalid packet id: " + comment)
	}
	state, err := strconv.Atoi(parts[1])
	if err != nil {
		return 0, 0, err
	}
	id, err := strconv.Atoi(parts[2])
	if err != nil {
		return 0, 0, err
	}
	return state, id, nil
}

func generate(packets []Packet) *jen.File {
	f := jen.NewFile("packet")
	f.HeaderComment("Code generated by generation/gen.go. DO NOT EDIT.")
	f.ImportName("gomc/src/protocol/types", "types")
	f.ImportName("gomc/src/protocol", "protocol")

	var constructors []jen.Code
	for _, p := range packets {
		if !strings.HasPrefix(p.Name, "Serverbound") {
			continue
		}
		constructors = append(constructors, jen.Id(fmt.Sprintf("serverbound[%d][%d]", p.State, p.Id)).
			Op("=").Func().Parens(nil).Id("SerializablePacket").Block(
			jen.Return(jen.Id("&"+p.Name).Block(nil)),
		))
	}
	if len(constructors) > 0 {
		f.Func().Id("init").Parens(nil).Block(constructors...).Line()
	}

	for _, p := range packets {
		var code []jen.Code
		code = append(code, jen.Var().Id("buf").Qual("bytes", "Buffer"))
		for _, field := range p.Fields {
			code = append(code, jen.Id("buf").Dot("Write").
				Parens(jen.Id(fmt.Sprintf("p.%s.Marshal()", field.Name))))
		}
		code = append(code, jen.Return(jen.Id("buf").Dot("Bytes").Parens(nil)))
		f.Func().Parens(jen.Id("p").Id("*" + p.Name)).Id("Serialize").
			Parens(nil).Id("[]byte").Block(code...).Line()
	}

	for _, p := range packets {
		var code []jen.Code
		b := "_"
		if len(p.Fields) > 0 {
			b = "b"
			code = append(code, jen.Var().Id("err").Id("error"))
			code = append(code, jen.Id("r").Op(":=").Qual("bytes", "NewReader").Parens(jen.Id("b")))
		}
		for _, field := range p.Fields {
			code = append(code, jen.List(jen.Id("p").Dot(field.Name), jen.Id("_"), jen.Id("err")).
				Op("=").Qual("gomc/src/protocol/types", "Read"+field.Type).Parens(jen.Id("r")))
			code = append(code, jen.If(jen.Id("err").Op("!=").Nil().Block(
				jen.Return(jen.Id("err")),
			)))
		}
		code = append(code, jen.Return(jen.Nil()))
		f.Func().Parens(jen.Id("p").Id("*" + p.Name)).Id("Deserialize").
			Parens(jen.Id(b).Id("[]byte")).Id("error").Block(code...).Line()
	}

	for _, p := range packets {
		f.Func().Parens(jen.Id("*" + p.Name)).Id("ID").Parens(nil).
			Id("int").Block(jen.Return().Id(strconv.Itoa(p.Id))).Line()
	}

	for _, p := range packets {
		f.Func().Parens(jen.Id("*"+p.Name)).Id("State").Parens(nil).
			Qual("gomc/src/protocol", "State").Block(jen.Return().Id(strconv.Itoa(p.State))).Line()
	}

	return f
}
